<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
  <head>
    <title>movingDots [PsychoPy]</title>
    <meta charset="UTF-8">
    <link href="js/vendors//jquery-ui-1.11.4.base/jquery-ui.min.css" rel="stylesheet">

    <style>
        /* project and resource dialogs */
        label, input { display:block; padding-bottom: .5em; }
        input.text { margin-bottom:1em; width:95%; padding: .5em; }
        fieldset { padding:0; border:0; margin-top:25px; }

        /* don't display close button in the top right corner of the box */
        .no-close .ui-dialog-titlebar-close { display: none; }
    </style>
  </head>

  <body>

    <!-- dialog place holder -->
    <div id="dialogDiv"/>

    <script type="text/javascript" src="js/vendors/Math2.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-ui-1.11.4.base/jquery-ui.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery.blockUI.js" ></script>
    <script type="text/javascript" src="js/vendors/stats.min.js"></script>
    <script type="text/javascript" src="js/vendors/pixi.min.js"></script>
    <script type="text/javascript" src="js/vendors/papaparse.min.js"></script>
    <script type="text/javascript" src="js/vendors/preloadjs-0.6.2.min.js"></script>

    <script type="text/javascript" src="js/psychojs/main.js"></script>
    <script type="text/javascript" src="js/psychojs/core.js"></script>
    <script type="text/javascript" src="js/psychojs/data.js"></script>
    <script type="text/javascript" src="js/psychojs/events.js"></script>
    <script type="text/javascript" src="js/psychojs/gui.js"></script>
    <script type="text/javascript" src="js/psychojs/util.js"></script>
    <script type="text/javascript" src="js/psychojs/scheduler.js"></script>
    <script type="text/javascript" src="js/psychojs/visual.js"></script>
    <script type="text/javascript" src="js/psychojs/io.js"></script>
    <script type="text/javascript" src="js/psychojs/jamdb.js"></script>
    <script type="text/javascript" src="js/psychojs/colors.js"></script>
    <script type="text/javascript" src="js/psychojs/logging.js"></script>

    <script type='text/javascript'>
      // wait until document is ready:
      $(document).ready(function() {
        psychoJS.debug = true; //false;
        
        function setupExperiment() {
        
          // An ExperimentHandler isn't essential but helps with data saving
          thisExp = new psychoJS.data.ExperimentHandler({
              name: 'movingDots',
              version: '',
              extraInfo: expInfo,
              runtimeInfo: undefined,  // not yet supported by psychoJS
              originPath: undefined,  //not yet supported by psychoJS
              savePickle: true,       // not yet supported by psychoJS
              saveWideText: true,
              saveTo: 'EXPERIMENT_SERVER',
              /*dataFileName=filename*/});
        
          // setup resource manager:
          psychoJS.resourceManager.set({
                                win:win, downloadFrom:'EXPERIMENT_SERVER', projectId:undefined,
                                projectStatus:'PUBLIC', clock:new psychoJS.core.Clock()
                                });
        
          endExpNow = false; // flag for 'escape' or other condition => quit the exp
        
          // logging:
          psychoJS.logging.console.setLevel(psychoJS.logging.EXP);
          psychoJS.logging.server.set({'level':psychoJS.logging.EXP, 'saveTo':'EXPERIMENT_SERVER', 'experimentInfo': expInfo});
        
          return psychoJS.NEXT;
        }
        
        function updateInfo() {
          expInfo['date'] = psychoJS.data.getDateStr();  // add a simple timestamp
          expInfo['expName'] = expName;
        
          // store frame rate of monitor if we can measure it successfully
          expInfo['frameRate'] = win.getActualFrameRate();
          if (expInfo['frameRate'] != undefined) {
              frameDur = 1.0/Math.round(expInfo['frameRate']);
          }
          else {
              frameDur = 1.0/60.0; // couldn't get a reliable measure so guess
          }
        
          return psychoJS.NEXT;
        }
        
        function setupWin() {
          // Start Code - component code to be run before the window creation
          // Setup the Window
          win = new psychoJS.visual.Window({size:[1280, 800],
              fullscr:true, screen:1.0,
              allowGUI:false, allowStencil:false,
              monitor:'testMonitor',
              color:[0,0,0], colorSpace:'rgb',
              blendMode:'avg',
              units:'use prefs'
              });
          return psychoJS.NEXT;
        }
        
        function experimentInit() {
          
          // Initialize components for Routine "obj1"
          obj1Clock = new psychoJS.core.Clock();
          image_4 = new psychoJS.visual.ImageStim({
              win : win, name : 'image_4',units : 'pix', 
              image : 'sin', mask : undefined,
              ori : 0, pos : [0,0], size : [150, 150],
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : 0.0 
          });
          
          // Initialize components for Routine "obj2"
          obj2Clock = new psychoJS.core.Clock();
          image_2 = new psychoJS.visual.ImageStim({
              win : win, name : 'image_2',units : 'pix', 
              image : 'sin', mask : undefined,
              ori : 0, pos : [0,0], size : [150, 150],
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : 0.0 
          });
          
          // Initialize components for Routine "obj3"
          obj3Clock = new psychoJS.core.Clock();
          image = new psychoJS.visual.ImageStim({
              win : win, name : 'image',units : 'pix', 
              image : 'sin', mask : undefined,
              ori : 0, pos : [0,0], size : [100, 100],
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : 0.0 
          });
          
          // Initialize components for Routine "obj4__2"
          obj4__2Clock = new psychoJS.core.Clock();
          image_5 = new psychoJS.visual.ImageStim({
              win : win, name : 'image_5',units : 'pix', 
              image : 'sin', mask : undefined,
              ori : 0, pos : [0,0], size : [100, 100],
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : 0.0 
          });
          
          // Initialize components for Routine "obj4_"
          obj4_Clock = new psychoJS.core.Clock();
          image_3 = new psychoJS.visual.ImageStim({
              win : win, name : 'image_3',units : 'pix', 
              image : 'sin', mask : undefined,
              ori : 0, pos : [0,0], size : [100, 100],
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : 0.0 
          });
          
          // Create some handy timers
          globalClock = new psychoJS.core.Clock();  // to track the time since experiment started
          routineTimer = new psychoJS.core.CountdownTimer();  // to track time remaining of each (non-slip) routine
          
          return psychoJS.NEXT;
        }
        
        function obj1RoutineBegin() {
          //------Prepare to start Routine 'obj1'-------
          t = 0;
          obj1Clock.reset(); // clock
          frameN = -1;
          // update component parameters for each repeat
          image_4.setPos([xpos.pop(), 0]);
          image_4.setImage(psychoJS.resourceManager.getResource(imgName));
          // keep track of which components have finished
          obj1Components = [];
          obj1Components.push(image_4);
          for(var i = 0; i < obj1Components.length; ++i) {
            thisComponent = obj1Components[i];
            if ('status' in thisComponent) {
              thisComponent.status = psychoJS.NOT_STARTED;
            }
          }
          
          return psychoJS.NEXT;
          }
          
          function obj1RoutineEachFrame() {
            //------Loop for each frame of Routine 'obj1'-------
            continueRoutine = true;
             // until we're told otherwise
            // get current time
            t = obj1Clock.getTime();
            frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
            // update/draw components on each frame
            
            // *image_4* updates
            if (t >= gistTime && image_4.status === psychoJS.NOT_STARTED) {
              // keep track of start time/frame for later
              image_4.tStart = t;  // (not accounting for frame time here)
              image_4.frameNStart = frameN;  // exact frame index
              image_4.setAutoDraw(true);
            }
            frameRemains = gistTime + 0.030 - frameDur * 0.75;  // most of one frame period left
            if (image_4.status === psychoJS.STARTED && t >= frameRemains) {
              image_4.setAutoDraw(false);
            }
            
            // check if the Routine should terminate
            if (!continueRoutine) {  // a component has requested a forced-end of Routine
              return psychoJS.NEXT;
            }
            continueRoutine = false;// reverts to True if at least one component still running
            for(var i = 0; i < obj1Components.length; ++i) {
              thisComponent = obj1Components[i];
              if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                continueRoutine = true;
                break;
              }
            }
            // check for quit (the Esc key)
            if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
              psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
            }
            
            // refresh the screen if continuing
            if (continueRoutine) {
              return psychoJS.FLIP_REPEAT;
            }
            else {
              return psychoJS.NEXT;
            }
          }
          
          function obj1RoutineEnd() {
            //------Ending Routine 'obj1'-------
            for (var i = 0; i < obj1Components.length; ++i) {
              thisComponent = obj1Components[i];
              if ("setAutoDraw" in thisComponent) {
                thisComponent.setAutoDraw(false);
              }
            }
            // the Routine "obj1" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset();
            return psychoJS.NEXT;
          }
          
          function obj3RoutineBegin() {
            //------Prepare to start Routine 'obj3'-------
            t = 0;
            obj3Clock.reset(); // clock
            frameN = -1;
            // update component parameters for each repeat
            image.setPos([xpos.pop(), 0]);
            image.setImage(psychoJS.resourceManager.getResource(imgName));
            // keep track of which components have finished
            obj3Components = [];
            obj3Components.push(image);
            for(var i = 0; i < obj3Components.length; ++i) {
              thisComponent = obj3Components[i];
              if ('status' in thisComponent) {
                thisComponent.status = psychoJS.NOT_STARTED;
              }
            }
            
            return psychoJS.NEXT;
            }
            
            function obj3RoutineEachFrame() {
              //------Loop for each frame of Routine 'obj3'-------
              continueRoutine = true;
               // until we're told otherwise
              // get current time
              t = obj3Clock.getTime();
              frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
              // update/draw components on each frame
              
              // *image* updates
              if (t >= gistTime && image.status === psychoJS.NOT_STARTED) {
                // keep track of start time/frame for later
                image.tStart = t;  // (not accounting for frame time here)
                image.frameNStart = frameN;  // exact frame index
                image.setAutoDraw(true);
              }
              frameRemains = gistTime + 0.030 - frameDur * 0.75;  // most of one frame period left
              if (image.status === psychoJS.STARTED && t >= frameRemains) {
                image.setAutoDraw(false);
              }
              
              // check if the Routine should terminate
              if (!continueRoutine) {  // a component has requested a forced-end of Routine
                return psychoJS.NEXT;
              }
              continueRoutine = false;// reverts to True if at least one component still running
              for(var i = 0; i < obj3Components.length; ++i) {
                thisComponent = obj3Components[i];
                if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                  continueRoutine = true;
                  break;
                }
              }
              // check for quit (the Esc key)
              if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
              }
              
              // refresh the screen if continuing
              if (continueRoutine) {
                return psychoJS.FLIP_REPEAT;
              }
              else {
                return psychoJS.NEXT;
              }
            }
            
            function obj3RoutineEnd() {
              //------Ending Routine 'obj3'-------
              for (var i = 0; i < obj3Components.length; ++i) {
                thisComponent = obj3Components[i];
                if ("setAutoDraw" in thisComponent) {
                  thisComponent.setAutoDraw(false);
                }
              }
              // the Routine "obj3" was not non-slip safe, so reset the non-slip timer
              routineTimer.reset();
              return psychoJS.NEXT;
            }
            
            function obj2RoutineBegin() {
              //------Prepare to start Routine 'obj2'-------
              t = 0;
              obj2Clock.reset(); // clock
              frameN = -1;
              // update component parameters for each repeat
              image_2.setPos([xpos.pop(), 0]);
              image_2.setImage(psychoJS.resourceManager.getResource(imgName));
              // keep track of which components have finished
              obj2Components = [];
              obj2Components.push(image_2);
              for(var i = 0; i < obj2Components.length; ++i) {
                thisComponent = obj2Components[i];
                if ('status' in thisComponent) {
                  thisComponent.status = psychoJS.NOT_STARTED;
                }
              }
              
              return psychoJS.NEXT;
              }
              
              function obj2RoutineEachFrame() {
                //------Loop for each frame of Routine 'obj2'-------
                continueRoutine = true;
                 // until we're told otherwise
                // get current time
                t = obj2Clock.getTime();
                frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                // update/draw components on each frame
                
                // *image_2* updates
                if (t >= gistTime && image_2.status === psychoJS.NOT_STARTED) {
                  // keep track of start time/frame for later
                  image_2.tStart = t;  // (not accounting for frame time here)
                  image_2.frameNStart = frameN;  // exact frame index
                  image_2.setAutoDraw(true);
                }
                frameRemains = gistTime + 0.030 - frameDur * 0.75;  // most of one frame period left
                if (image_2.status === psychoJS.STARTED && t >= frameRemains) {
                  image_2.setAutoDraw(false);
                }
                
                // check if the Routine should terminate
                if (!continueRoutine) {  // a component has requested a forced-end of Routine
                  return psychoJS.NEXT;
                }
                continueRoutine = false;// reverts to True if at least one component still running
                for(var i = 0; i < obj2Components.length; ++i) {
                  thisComponent = obj2Components[i];
                  if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                    continueRoutine = true;
                    break;
                  }
                }
                // check for quit (the Esc key)
                if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                  psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                }
                
                // refresh the screen if continuing
                if (continueRoutine) {
                  return psychoJS.FLIP_REPEAT;
                }
                else {
                  return psychoJS.NEXT;
                }
              }
              
              function obj2RoutineEnd() {
                //------Ending Routine 'obj2'-------
                for (var i = 0; i < obj2Components.length; ++i) {
                  thisComponent = obj2Components[i];
                  if ("setAutoDraw" in thisComponent) {
                    thisComponent.setAutoDraw(false);
                  }
                }
                // the Routine "obj2" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset();
                return psychoJS.NEXT;
              }
              
              function obj4RoutineBegin() {
                //------Prepare to start Routine 'obj4'-------
                t = 0;
                obj4Clock.reset(); // clock
                frameN = -1;
                // update component parameters for each repeat
                // keep track of which components have finished
                obj4Components = [];
                for(var i = 0; i < obj4Components.length; ++i) {
                  thisComponent = obj4Components[i];
                  if ('status' in thisComponent) {
                    thisComponent.status = psychoJS.NOT_STARTED;
                  }
                }
                
                return psychoJS.NEXT;
                }
                
                function obj4RoutineEachFrame() {
                  //------Loop for each frame of Routine 'obj4'-------
                  continueRoutine = true;
                   // until we're told otherwise
                  // get current time
                  t = obj4Clock.getTime();
                  frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                  // update/draw components on each frame
                  
                  // check if the Routine should terminate
                  if (!continueRoutine) {  // a component has requested a forced-end of Routine
                    return psychoJS.NEXT;
                  }
                  continueRoutine = false;// reverts to True if at least one component still running
                  for(var i = 0; i < obj4Components.length; ++i) {
                    thisComponent = obj4Components[i];
                    if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                      continueRoutine = true;
                      break;
                    }
                  }
                  // check for quit (the Esc key)
                  if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                    psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                  }
                  
                  // refresh the screen if continuing
                  if (continueRoutine) {
                    return psychoJS.FLIP_REPEAT;
                  }
                  else {
                    return psychoJS.NEXT;
                  }
                }
                
                function obj4RoutineEnd() {
                  //------Ending Routine 'obj4'-------
                  for (var i = 0; i < obj4Components.length; ++i) {
                    thisComponent = obj4Components[i];
                    if ("setAutoDraw" in thisComponent) {
                      thisComponent.setAutoDraw(false);
                    }
                  }
                  // the Routine "obj4" was not non-slip safe, so reset the non-slip timer
                  routineTimer.reset();
                  return psychoJS.NEXT;
                }
                
                function obj8RoutineBegin() {
                  //------Prepare to start Routine 'obj8'-------
                  t = 0;
                  obj8Clock.reset(); // clock
                  frameN = -1;
                  // update component parameters for each repeat
                  // keep track of which components have finished
                  obj8Components = [];
                  for(var i = 0; i < obj8Components.length; ++i) {
                    thisComponent = obj8Components[i];
                    if ('status' in thisComponent) {
                      thisComponent.status = psychoJS.NOT_STARTED;
                    }
                  }
                  
                  return psychoJS.NEXT;
                  }
                  
                  function obj8RoutineEachFrame() {
                    //------Loop for each frame of Routine 'obj8'-------
                    continueRoutine = true;
                     // until we're told otherwise
                    // get current time
                    t = obj8Clock.getTime();
                    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                    // update/draw components on each frame
                    
                    // check if the Routine should terminate
                    if (!continueRoutine) {  // a component has requested a forced-end of Routine
                      return psychoJS.NEXT;
                    }
                    continueRoutine = false;// reverts to True if at least one component still running
                    for(var i = 0; i < obj8Components.length; ++i) {
                      thisComponent = obj8Components[i];
                      if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                        continueRoutine = true;
                        break;
                      }
                    }
                    // check for quit (the Esc key)
                    if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                      psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                    }
                    
                    // refresh the screen if continuing
                    if (continueRoutine) {
                      return psychoJS.FLIP_REPEAT;
                    }
                    else {
                      return psychoJS.NEXT;
                    }
                  }
                  
                  function obj8RoutineEnd() {
                    //------Ending Routine 'obj8'-------
                    for (var i = 0; i < obj8Components.length; ++i) {
                      thisComponent = obj8Components[i];
                      if ("setAutoDraw" in thisComponent) {
                        thisComponent.setAutoDraw(false);
                      }
                    }
                    // the Routine "obj8" was not non-slip safe, so reset the non-slip timer
                    routineTimer.reset();
                    return psychoJS.NEXT;
                  }
                  
                  function obj4__2RoutineBegin() {
                    //------Prepare to start Routine 'obj4__2'-------
                    t = 0;
                    obj4__2Clock.reset(); // clock
                    frameN = -1;
                    // update component parameters for each repeat
                    image_5.setPos([xpos.pop(), 0]);
                    image_5.setImage(psychoJS.resourceManager.getResource(imgName));
                    // keep track of which components have finished
                    obj4__2Components = [];
                    obj4__2Components.push(image_5);
                    for(var i = 0; i < obj4__2Components.length; ++i) {
                      thisComponent = obj4__2Components[i];
                      if ('status' in thisComponent) {
                        thisComponent.status = psychoJS.NOT_STARTED;
                      }
                    }
                    
                    return psychoJS.NEXT;
                    }
                    
                    function obj4__2RoutineEachFrame() {
                      //------Loop for each frame of Routine 'obj4__2'-------
                      continueRoutine = true;
                       // until we're told otherwise
                      // get current time
                      t = obj4__2Clock.getTime();
                      frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                      // update/draw components on each frame
                      
                      // *image_5* updates
                      if (t >= gistTime && image_5.status === psychoJS.NOT_STARTED) {
                        // keep track of start time/frame for later
                        image_5.tStart = t;  // (not accounting for frame time here)
                        image_5.frameNStart = frameN;  // exact frame index
                        image_5.setAutoDraw(true);
                      }
                      frameRemains = gistTime + 0.030 - frameDur * 0.75;  // most of one frame period left
                      if (image_5.status === psychoJS.STARTED && t >= frameRemains) {
                        image_5.setAutoDraw(false);
                      }
                      
                      // check if the Routine should terminate
                      if (!continueRoutine) {  // a component has requested a forced-end of Routine
                        return psychoJS.NEXT;
                      }
                      continueRoutine = false;// reverts to True if at least one component still running
                      for(var i = 0; i < obj4__2Components.length; ++i) {
                        thisComponent = obj4__2Components[i];
                        if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                          continueRoutine = true;
                          break;
                        }
                      }
                      // check for quit (the Esc key)
                      if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                        psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                      }
                      
                      // refresh the screen if continuing
                      if (continueRoutine) {
                        return psychoJS.FLIP_REPEAT;
                      }
                      else {
                        return psychoJS.NEXT;
                      }
                    }
                    
                    function obj4__2RoutineEnd() {
                      //------Ending Routine 'obj4__2'-------
                      for (var i = 0; i < obj4__2Components.length; ++i) {
                        thisComponent = obj4__2Components[i];
                        if ("setAutoDraw" in thisComponent) {
                          thisComponent.setAutoDraw(false);
                        }
                      }
                      // the Routine "obj4__2" was not non-slip safe, so reset the non-slip timer
                      routineTimer.reset();
                      return psychoJS.NEXT;
                    }
                    
                    function obj4_RoutineBegin() {
                      //------Prepare to start Routine 'obj4_'-------
                      t = 0;
                      obj4_Clock.reset(); // clock
                      frameN = -1;
                      // update component parameters for each repeat
                      image_3.setPos([xpos.pop(), 0]);
                      image_3.setImage(psychoJS.resourceManager.getResource(imgName));
                      // keep track of which components have finished
                      obj4_Components = [];
                      obj4_Components.push(image_3);
                      for(var i = 0; i < obj4_Components.length; ++i) {
                        thisComponent = obj4_Components[i];
                        if ('status' in thisComponent) {
                          thisComponent.status = psychoJS.NOT_STARTED;
                        }
                      }
                      
                      return psychoJS.NEXT;
                      }
                      
                      function obj4_RoutineEachFrame() {
                        //------Loop for each frame of Routine 'obj4_'-------
                        continueRoutine = true;
                         // until we're told otherwise
                        // get current time
                        t = obj4_Clock.getTime();
                        frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
                        // update/draw components on each frame
                        
                        // *image_3* updates
                        if (t >= gistTime && image_3.status === psychoJS.NOT_STARTED) {
                          // keep track of start time/frame for later
                          image_3.tStart = t;  // (not accounting for frame time here)
                          image_3.frameNStart = frameN;  // exact frame index
                          image_3.setAutoDraw(true);
                        }
                        frameRemains = gistTime + 0.030 - frameDur * 0.75;  // most of one frame period left
                        if (image_3.status === psychoJS.STARTED && t >= frameRemains) {
                          image_3.setAutoDraw(false);
                        }
                        
                        // check if the Routine should terminate
                        if (!continueRoutine) {  // a component has requested a forced-end of Routine
                          return psychoJS.NEXT;
                        }
                        continueRoutine = false;// reverts to True if at least one component still running
                        for(var i = 0; i < obj4_Components.length; ++i) {
                          thisComponent = obj4_Components[i];
                          if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                            continueRoutine = true;
                            break;
                          }
                        }
                        // check for quit (the Esc key)
                        if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                          psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
                        }
                        
                        // refresh the screen if continuing
                        if (continueRoutine) {
                          return psychoJS.FLIP_REPEAT;
                        }
                        else {
                          return psychoJS.NEXT;
                        }
                      }
                      
                      function obj4_RoutineEnd() {
                        //------Ending Routine 'obj4_'-------
                        for (var i = 0; i < obj4_Components.length; ++i) {
                          thisComponent = obj4_Components[i];
                          if ("setAutoDraw" in thisComponent) {
                            thisComponent.setAutoDraw(false);
                          }
                        }
                        // the Routine "obj4_" was not non-slip safe, so reset the non-slip timer
                        routineTimer.reset();
                        return psychoJS.NEXT;
                      }
                      
                      function registerResources() {
                          psychoJS.resourceManager.scheduleRegistration(resourceScheduler);
                      
                          return psychoJS.NEXT;
                      }
                      
                      function downloadResources() {
                          psychoJS.resourceManager.scheduleDownload(resourceScheduler);
                      
                          return psychoJS.NEXT;
                      }
                      
                      function trialsLoopBegin(thisScheduler) {
                        // set up handler to look after randomisation of conditions etc
                        try {
                          trials = new psychoJS.data.TrialHandler({nReps:1, method:'random',
                            extraInfo:expInfo, originPath:undefined,
                            trialList:psychoJS.data.importConditions('conditions.xlsx'),
                            seed:undefined, name:'trials'});
                          thisExp.addLoop(trials); // add the loop to the experiment
                          thisTrial = trials.trialList[trials.trialSequence[0]]; // so we can initialise stimuli with some values
                          // abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)
                          abbrevNames(thisTrial);
                          // Schedule each of the trials in the list to occur
                          for (var i = 0; i < trials.trialSequence.length; ++i) {
                            thisTrial = trials.trialList[trials.trialSequence[i]];
                            thisScheduler.add(abbrevNames(thisTrial));
                            thisScheduler.add(obj1RoutineBegin);
                            thisScheduler.add(obj1RoutineEachFrame);
                            thisScheduler.add(obj1RoutineEnd);
                            thisScheduler.add(obj2RoutineBegin);
                            thisScheduler.add(obj2RoutineEachFrame);
                            thisScheduler.add(obj2RoutineEnd);
                            thisScheduler.add(obj3RoutineBegin);
                            thisScheduler.add(obj3RoutineEachFrame);
                            thisScheduler.add(obj3RoutineEnd);
                            thisScheduler.add(obj4__2RoutineBegin);
                            thisScheduler.add(obj4__2RoutineEachFrame);
                            thisScheduler.add(obj4__2RoutineEnd);
                            thisScheduler.add(obj4_RoutineBegin);
                            thisScheduler.add(obj4_RoutineEachFrame);
                            thisScheduler.add(obj4_RoutineEnd);
                            thisScheduler.add(recordLoopIteration(trials));
                          }
                        } catch (exception) {
                          console.log(exception);
                        }
                      
                        return psychoJS.NEXT;
                      }
                      
                      function trialsLoopEnd() {
                        // get names of stimulus parameters
                        if (psychoJS.isEmpty(trials.trialList)) { // XXX equiv of : in ([], [None], None)
                          params = [];
                        }
                        else {
                          params = Object.keys(trials.trialList[0]);
                        }
                      
                        // save data for this loop
                        thisExp.loopEnded(trials);
                        return psychoJS.NEXT;
                        }
                      
                      function run() {
                        // init psychoJS and set up OpenGL Canvas
                        setupWin();
                        psychoJS.init(win);
                        
                        // main scheduler
                        scheduler = new psychoJS.Scheduler();
                        
                        // Store info about the experiment session
                        expName = 'stroop';  // from the Builder filename that created this script
                        expInfo = {'participant':'', 'session':'01'};
                        
                        // set up experiment
                        scheduler.add(setupExperiment);
                        scheduler.add(psychoJS.setupCallbacks);
                        
                        // register all available resources and download them
                        resourceScheduler = new psychoJS.Scheduler();
                        resourceScheduler.add(registerResources);
                        resourceScheduler.add(downloadResources);
                        // asynchronous approach: the resource scheduler is run in parallel to the main one
                        scheduler.add(function() { resourceScheduler.start(win); });
                        
                        // dialog box
                        scheduler.add(psychoJS.gui.DlgFromDict({dictionary:expInfo, title:expName}));
                        
                        flowScheduler = new psychoJS.Scheduler();
                        dialogCancelScheduler = new psychoJS.Scheduler();
                        scheduler.addConditionalBranches(function() { return psychoJS.gui.dialogComponent.button === 'OK'; }, flowScheduler, dialogCancelScheduler);
                        
                        // flowScheduler gets run if the participants presses OK
                        flowScheduler.add(updateInfo); // add timeStamp
                        flowScheduler.add(experimentInit);
                        trialsLoopScheduler = new psychoJS.Scheduler();
                        flowScheduler.add(trialsLoopBegin, trialsLoopScheduler);
                        flowScheduler.add(trialsLoopScheduler);
                        flowScheduler.add(trialsLoopEnd);
                        flowScheduler.add(quitPsychoJS);
                        
                        // quit if user presses Cancel in dialog box:
                        dialogCancelScheduler.add(quitPsychoJS);
                        
                        scheduler.start(win);
                      }
                      
                      function abbrevNames(thisTrial) {
                        return function () {
                          // abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)
                          if (thisTrial != undefined) {
                            for (paramName in thisTrial) {
                              window[paramName] = thisTrial[paramName];
                            }
                          }
                          return psychoJS.NEXT;
                        };
                      }
                      
                      function recordLoopIteration(currentLoop) {
                        return function () {
                          currentLoop.updateAttributesAtBegin();
                          thisExp.nextEntry();
                          return psychoJS.NEXT;
                        }
                      }
                      
                      function quitPsychoJS() {
                          thisExp.save();
                          win.close()
                          psychoJS.core.quit();
                          return psychoJS.QUIT;
                      }

        run();
      });
    </script>

  </body>
</html>
